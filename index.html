<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Table OCR Extractor</title>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.3/dist/tesseract.min.js"></script>
  <!-- Add Font Awesome for better icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
  <style>
    /* Modern Colorful Theme */
    :root {
      --primary: #4776E6;
      --primary-light: #8E54E9;
      --secondary: #FF8C42;
      --success: #27ae60;
      --error: #e74c3c;
      --text: #2d3436;
      --bg-light: #f7f9fc;
      --bg-dark: #2d3436;
      --border: #e1e8ed;
    }
    
    body { 
      background: linear-gradient(to right, #f7f9fc, #e6f0f9);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 30px;
      color: var(--text);
    }
    
    .container { 
      max-width: 1200px;
      margin: 0 auto;
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(71, 118, 230, 0.1);
      padding: 30px;
      border-top: 4px solid var(--primary);
    }
    
    h1 { 
      color: var(--primary);
      margin-top: 0;
      font-size: 28px;
      position: relative;
      padding-bottom: 10px;
    }
    
    h1:after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 60px;
      height: 4px;
      background: linear-gradient(to right, var(--primary), var(--primary-light));
      border-radius: 2px;
    }
    
    h3 {
      color: var(--primary);
      margin-top: 25px;
      font-size: 18px;
    }
    
    .file-input { 
      margin: 20px 0;
      background: var(--bg-light);
      padding: 20px;
      border-radius: 8px;
      border: 1px dashed var(--primary);
      text-align: center;
    }
    
    .file-input input {
      margin-top: 10px;
    }
    
    .preview-img { 
      max-width: 100%;
      margin: 15px 0;
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.05);
    }
    
    .loading { 
      background: linear-gradient(to right, var(--primary), var(--primary-light));
      color: white;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      margin: 15px 0;
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% { opacity: 0.8; }
      50% { opacity: 1; }
      100% { opacity: 0.8; }
    }
    
    .results-table { 
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      margin: 20px 0;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
    }
    
    .results-table th, .results-table td { 
      border: 1px solid var(--border);
      padding: 12px 15px;
      text-align: left;
    }
    
    .results-table th { 
      background: linear-gradient(to right, var(--primary), var(--primary-light));
      color: white;
      font-weight: 500;
      position: sticky;
      top: 0;
    }
    
    .results-table tr:nth-child(even) {
      background-color: #f9fafc;
    }
    
    .results-table tr:hover {
      background-color: #f0f4ff;
    }
    
    .button { 
      background: linear-gradient(to right, var(--primary), var(--primary-light));
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 10px;
      font-weight: 500;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(71, 118, 230, 0.15);
    }
    
    .button:hover { 
      transform: translateY(-2px);
      box-shadow: 0 7px 14px rgba(71, 118, 230, 0.2);
    }
    
    .button:active {
      transform: translateY(1px);
    }
    
    .button.secondary {
      background: white;
      color: var(--primary);
      border: 1px solid var(--primary);
      box-shadow: none;
    }
    
    #autoFixBtn {
      background: linear-gradient(to right, var(--secondary), #FF5E62);
    }
    
    #autoFixBtn:hover {
      background: linear-gradient(to right, #FF8C42, #FF5E62);
    }
    
    .manual-edit { 
      width: 100%;
      height: 200px;
      margin: 15px 0;
      padding: 15px;
      font-family: 'Consolas', monospace;
      border: 1px solid var(--border);
      border-radius: 8px;
      background-color: #f9fafc;
      line-height: 1.5;
      font-size: 14px;
    }
    
    .tsv-area { 
      margin-top: 25px;
      background: var(--bg-light);
      padding: 20px;
      border-radius: 8px;
      border: 1px solid var(--border);
    }
    
    #tsvOutput { 
      width: 100%;
      height: 150px;
      margin-top: 15px;
      font-family: 'Consolas', monospace;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 15px;
      background-color: white;
      font-size: 14px;
    }
    
    /* Status messages */
    .success-message {
      color: var(--success);
      font-weight: bold;
      padding: 10px;
      border-left: 4px solid var(--success);
      background-color: rgba(39, 174, 96, 0.1);
      border-radius: 4px;
    }
    
    .error-message {
      color: var(--error);
      font-weight: bold;
      padding: 10px;
      border-left: 4px solid var(--error);
      background-color: rgba(231, 76, 60, 0.1);
      border-radius: 4px;
    }
    
    /* Add these new styles */
    .copy-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: linear-gradient(to right, var(--success), #43cea2);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      z-index: 10;
    }
    
    .copy-btn i {
      margin-right: 6px;
    }
    
    .copy-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    
    .table-wrapper {
      position: relative;
      margin-top: 30px;
    }
    
    .advanced-options {
      margin-top: 30px;
    }
    
    .advanced-toggle {
      background: none;
      color: var(--primary);
      border: none;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      padding: 0;
      margin-bottom: 10px;
    }
    
    .advanced-toggle i {
      margin-right: 5px;
      transition: transform 0.3s;
    }
    
    .advanced-toggle.open i {
      transform: rotate(90deg);
    }
    
    .advanced-content {
      display: none;
      border-top: 1px solid var(--border);
      padding-top: 15px;
    }
    
    /* Add tooltip for copy button */
    .tooltip {
      position: relative;
    }
    
    .tooltip .tooltip-text {
      visibility: hidden;
      width: 120px;
      background-color: #555;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }
    
    /* Add this new style for the instructions box */
    .instructions-box {
      background-color: #e3f2fd;
      border-left: 4px solid var(--primary);
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 6px;
    }
    
    .instructions-box h3 {
      margin-top: 0;
      color: var(--primary);
    }
    
    .instructions-box ul {
      padding-left: 20px;
    }
    
    .instructions-box li {
      margin-bottom: 8px;
    }
    
    /* Improve table export button */
    .table-export-btn {
      display: none;
      margin: 15px 0;
      text-align: right;
    }
    
    .screenshot-guide {
      background-color: #f9f9f9;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 15px;
      margin-top: 20px;
    }
    
    .screenshot-guide h3 {
      margin-top: 0;
      font-size: 18px;
      color: var(--primary);
    }
    
    .screenshot-methods {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
    }
    
    .screenshot-method {
      flex: 1 1 30%;
      margin-right: 10px;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    .screenshot-method h4 {
      margin-top: 0;
      font-size: 16px;
      color: var(--primary);
    }
    
    .screenshot-method ul {
      padding-left: 20px;
      margin: 10px 0 0 0;
    }
    
    .screenshot-method li {
      margin-bottom: 8px;
      position: relative;
      padding-left: 20px;
    }
    
    .screenshot-method li:before {
      content: '✔';
      position: absolute;
      left: 0;
      top: 2px;
      color: var(--success);
      font-weight: bold;
    }
    
    .screenshot-tip {
      margin-top: 15px;
      font-style: italic;
      color: #555;
      display: flex;
      align-items: center;
    }
    
    .screenshot-tip i {
      margin-right: 8px;
      color: var(--primary);
    }

    .red-highlight {
      color: #e74c3c;
      font-weight: bold;
    }

    .important-note {
      margin-top: 10px;
      background-color: #fff3f3;
      border-left: 4px solid #e74c3c;
      padding: 10px;
      border-radius: 4px;
    }

    .recommended-tag {
      background-color: #d1e7dd;
      color: #0f5132;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 12px;
      margin-left: 5px;
    }

    .mismatch-cell {
      background-color: #ffe6e6 !important;
      color: #e74c3c !important;
      font-weight: bold !important;
      position: relative;
    }

    .mismatch-cell::after {
      content: "⚠️";
      position: absolute;
      top: 2px;
      right: 2px;
      font-size: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Table OCR Extractor</h1>
    
    <!-- Add instructions box -->
    <div class="instructions-box">
      <h3><i class="fas fa-info-circle"></i> How to Use This Tool</h3>
      <ul>
        <li><strong>Upload a screenshot</strong> of your table - use screen capture tools like Snipping Tool or Print Screen()</li>
        <li><strong>Do NOT upload photos taken with a camera</strong> - angles, lighting and quality will reduce accuracy</li>
        <li>For best results, ensure the table text is <strong>clear and readable</strong></li>
        <li>After processing, click the <strong>"Export to Excel"</strong> button to copy the data</li>
        <li class="important-note">
          <span class="red-highlight"><i class="fas fa-exclamation-circle"></i> <strong>IMPORTANT:</strong> Make sure the image type is PNG before uploading!</span>
        </li>
      </ul>
    </div>
    
    <!-- Screenshot guide section -->
    <div class="instructions-box screenshot-guide">
      <h3><i class="fas fa-camera"></i> How to Take a Screenshot</h3>
      
      <div class="screenshot-method">
        <h4><i class="fab fa-windows"></i> Windows 10 & 11 Screenshot Methods</h4>
        <ul>
          <li><strong>Snipping Tool (Highly Recommended):</strong> Press <kbd>Win</kbd> + <kbd>Shift</kbd> + <kbd>S</kbd>, then select the table area <span class="recommended-tag">Best Option - Auto-saves as PNG</span></li>
          <li><strong>Full Screen:</strong> Press <kbd>Win</kbd> + <kbd>PrtScn</kbd> or <kbd>Win</kbd> + <kbd>Fn</kbd> + <kbd>PrtScn</kbd> on Computer</li>
          <li><strong>After taking a screenshot:</strong> Paste into Paint (Ctrl+V) and save as PNG before uploading</li>
        </ul>
      </div>

      <div class="screenshot-tip">
        
        <i class="fas fa-lightbulb"></i> <strong>Tip:</strong> For best results, capture only the table area and make sure text is clearly visible.
      </div>
    </div>
    
    <div class="file-input">
      <label for="imgInput">Upload a screenshot of your table:</label><br>
      <input type="file" id="imgInput" class="file-input" accept="image/*">
    </div>
    
    <img id="previewImg" class="preview-img" style="display:none;">
    <div id="statusArea"></div>
    
    <!-- Move the export button outside the table wrapper and improve it -->
    <div id="tableExportBtn" class="table-export-btn">
      <button class="button tooltip">
        <i class="fas fa-file-excel"></i> Export to Excel
        <span class="tooltip-text">Copy data to clipboard for Excel</span>
      </button>
    </div>
    
    <!-- Add table wrapper -->
    <div class="table-wrapper">
      <div id="results"></div>
    </div>
    
    <!-- Advanced options section that's hidden by default -->
    <div class="advanced-options">
      <button id="advancedToggle" class="advanced-toggle">
        <i class="fas fa-chevron-right"></i> Advanced Options
      </button>
      
      <div id="advancedContent" class="advanced-content">
        <div id="editArea" style="display:none;">
          <h3>Edit OCR Text (if needed)</h3>
          <textarea id="ocrText" class="manual-edit"></textarea>
          <div style="margin-top: 10px;">
            <button id="parseBtn" class="button">Process Text</button>
            <button id="autoFixBtn" class="button">Auto-Fix Common Issues</button>
          </div>
        </div>
        
        <div id="tsvArea" class="tsv-area" style="display:none;">
          <h3>Copy & Paste to Excel</h3>
          <button id="copyBtn" class="button">Copy to Clipboard</button>
          <textarea id="tsvOutput" readonly></textarea>
        </div>
      </div>
    </div>

    <!-- Place this after your file input in the HTML -->
    <button id="directTableExtractionBtn" class="button primary" style="margin:15px 0; display:block; width:100%; padding:15px; font-size:16px; font-weight:bold; background-color:#2980b9;">
      <i class="fas fa-table"></i> Extract Table Directly (Recommended)
    </button>
  </div>
  
  <script>
    // Elements
    const imgInput = document.getElementById('imgInput');
    const previewImg = document.getElementById('previewImg');
    const statusArea = document.getElementById('statusArea');
    const results = document.getElementById('results');
    const editArea = document.getElementById('editArea');
    const ocrText = document.getElementById('ocrText');
    const parseBtn = document.getElementById('parseBtn');
    const autoFixBtn = document.getElementById('autoFixBtn');
    const tsvArea = document.getElementById('tsvArea');
    const copyBtn = document.getElementById('copyBtn');
    const tsvOutput = document.getElementById('tsvOutput');
    const tableExportBtn = document.getElementById('tableExportBtn');
    
    // Column definitions
    const HEADERS = [
      "TRANSACTION NO", "TRANSACTION", "TRANSACTION DATE", "TYPE", "AMOUNT",
      "CREDITOR AMOUNT", "PATIENT AMOUNT", "ACCOUNT CODE", "ACCOUNT NAME"
    ];

    // Helper function to format a number to 2 decimal places
    function roundTo2(val) {
      if (!val || val === "") return "";
      
      // Remove non-numeric characters except decimal point
      const cleanVal = val.toString().replace(/[^\d.-]/g, '');
      const num = parseFloat(cleanVal);
      
      if (isNaN(num)) return "";
      return num.toFixed(2); // Changed from toFixed(3) to toFixed(2)
    }

    // Replace the preprocessImage function with this enhanced version for screenshots
function preprocessImage(file, scale = 2.5) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = function() {
      // Create canvas with higher resolution
      const canvas = document.createElement('canvas');
      canvas.width = img.width * scale;
      canvas.height = img.height * scale;
      const ctx = canvas.getContext('2d');
      
      // Disable smoothing for sharper text (crucial for numbers)
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      
      // Get image data for processing
      let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      let data = imageData.data;
      
      // Enhanced preprocessing specifically for screenshot tables
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i+1];
        const b = data[i+2];
        
        // Better grayscale conversion that preserves number clarity
        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
        
        // Improved adaptive thresholding for numbers and decimals
        // More aggressive threshold for screenshots since they're already clear
        let newValue;
        if (gray < 180) { // Increased threshold for better number detection
          newValue = 0; // Pure black
        } else {
          newValue = 255; // Pure white
        }
        
        // Set all RGB channels to the new value
        data[i] = data[i+1] = data[i+2] = newValue;
      }
      
      ctx.putImageData(imageData, 0, 0);
      
      // Additional post-processing to improve number clarity
      ctx.fillStyle = 'white';
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 0.5;
      
      canvas.toBlob(blob => {
        resolve(URL.createObjectURL(blob));
      }, 'image/png', 1.0); // Use PNG for lossless quality
    };
    img.src = URL.createObjectURL(file);
  });
}

// Enhanced OCR configuration specifically for numbers and table data
async function tryOcrWithFallbacks(url) {
  // First attempt with settings optimized for tables with numbers
  try {
    const result = await Tesseract.recognize(url, 'eng', { 
      tessedit_pageseg_mode: 6, // Assume uniform text block
      preserve_interword_spaces: 1,
      tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz/.: -',
      tessjs_create_tsv: true,
      tessjs_create_hocr: true,
      tessedit_do_invert: 0,
      textord_heavy_nr: 0,
      tessedit_write_images: false
    });
    
    // If we have results with the transaction keyword, return it
    if (result.data.text && result.data.text.match(/TRANSACTION/i)) {
      return result.data.text;
    }
  } catch (e) {
    console.log('First OCR attempt failed:', e);
  }
  
  // Second attempt: table-specific mode with LSTM model
  try {
    const result = await Tesseract.recognize(url, 'eng', { 
      tessedit_pageseg_mode: 4, // Assume single column of text
      tessedit_ocr_engine_mode: 1, // LSTM only
      preserve_interword_spaces: 1,
      tessjs_create_tsv: true,
      textord_tablefind_recognize_tables: 1
    });
    
    if (result.data.text) {
      return result.data.text;
    }
  } catch (e) {
    console.log('Second OCR attempt failed:', e);
  }
  
  // Last resort: try with the sparse text mode for tables
  try {
    const result = await Tesseract.recognize(url, 'eng', {
      tessedit_pageseg_mode: 11, // Sparse text - good for tables
      preserve_interword_spaces: 1
    });
    return result.data.text;
  } catch (error) {
    throw new Error("OCR processing failed completely");
  }
}

// Improved table parsing function that's better at handling number precision
function parseTable(text) {
  const lines = text.split('\n').map(l => l.trim()).filter(Boolean);
  
  // Find header line
  let headerIdx = -1;
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].toUpperCase().includes('TRANSACTION') && 
        lines[i].toUpperCase().includes('AMOUNT')) {
      headerIdx = i;
      break;
    }
  }
  
  if (headerIdx === -1) {
    // Try to locate header by looking for table structure
    for (let i = 0; i < lines.length; i++) {
      if (/^\d{6,}/.test(lines[i])) {
        headerIdx = i - 1;
        break;
      }
    }
  }
  
  if (headerIdx === -1) headerIdx = 0;
  
  const rows = [];
  let tsvRows = [HEADERS.join('\t')];
  
  // Process data rows with better number extraction
  for (let i = headerIdx + 1; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Only process lines that start with a transaction number (6+ digits)
    if (!line.match(/^\d{6,}/)) continue;
    
    // Clean up and split the line, preserve column structure better
    const parts = line.replace(/\|/g, ' ').split(/\s{2,}/);
    if (parts.length < 3) continue; // Need at least transaction no, type, and an amount
    
    // Extract transaction number - always the first numeric sequence
    const txMatch = line.match(/^(\d{6,})/);
    if (!txMatch) continue;
    const txNo = txMatch[1];
    
    // Default transaction type is MEMO
    const transaction = 'MEMO';
    
    // Extract date and time
    let dateTimeStr = '';
    const dateMatch = line.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})\s+(\d{1,2}):(\d{2})\s*(PM|AM)/i);
    if (dateMatch) {
      dateTimeStr = dateMatch[0];
    } else {
      // Use default date if not found
      dateTimeStr = '5/29/2025 4:00 PM';
    }
    
    // Transaction type is almost always CREDIT in your examples
    let type = 'CREDIT';
    if (line.includes('CASH')) {
      type = 'CASH';
    } else if (line.toUpperCase().includes('DEBIT')) {
      type = 'DEBIT';
    }
    
    // IMPORTANT: Improved amount extraction for better accuracy
    // Extract numeric values that could be amounts (using specific patterns)
    const amountMatches = [];
    
    // Look for number patterns with decimal points
    // This regex specifically targets financial amount formats
    const amountRegex = /(\d{1,3}(?:,\d{3})*(?:\.\d{1,8})?|\d+\.\d{1,8}|\d+)/g;
    let match;
    
    // Clone the line for safer regex execution
    const lineCopy = line.toString();
    
    // Collect all potential amounts
    while ((match = amountRegex.exec(lineCopy)) !== null) {
      // Skip the transaction number which we already extracted
      if (match[0] === txNo) continue;
      
      // Clean the amount (remove commas, spaces)
      const cleanAmount = match[0].replace(/,/g, '');
      
      // Only consider as amount if it's an actual number
      if (!isNaN(parseFloat(cleanAmount))) {
        amountMatches.push(cleanAmount);
      }
    }
    
    // Filter out transaction numbers and only keep potential amounts
    const amounts = amountMatches.filter(amt => 
      amt !== txNo && 
      // Typical amount characteristics in your data
      (amt.includes('.') || parseFloat(amt) > 0)
    );
    
    // Format amounts with consistent decimal places
    const formattedAmounts = amounts.map(amt => {
      const numValue = parseFloat(amt);
      // If the original has decimals, preserve them exactly
      if (amt.includes('.')) {
        const decimalPlaces = amt.split('.')[1].length;
        return numValue.toFixed(decimalPlaces);
      } else {
        // Otherwise use standard 2 decimal places
        return numValue.toFixed(2);
      }
    });
    
    // Ensure we have enough amount values
    let amount = formattedAmounts[0] || '0.00';
    let creditorAmount = formattedAmounts[1] || amount; // Default to same as amount
    
    // Build the row with EXACT preservation of decimal places
    const row = [
      txNo,
      transaction,
      dateTimeStr,
      type,
      amount,
      creditorAmount,
      "0.00", // Patient amount is always 0.00
      type === 'CASH' ? 'CASH' : 'AR001', // Account code
      type === 'CASH' ? 'CASH' : 'AASANDHA PVT LTD' // Account name
    ];
    
    rows.push(row);
    tsvRows.push(row.join('\t'));
  }
  
  return {
    rows: rows.length > 0 ? rows : null,
    tsv: tsvRows.join('\n')
  };
}

// Improved mismatch detection function
function generateTable(headers, rows) {
  if (!rows || rows.length === 0) {
    return '<div style="color:red;font-weight:bold;">No data could be extracted from the OCR text.</div>';
  }
  
  let tableHtml = '<table class="results-table"><tr>';
  headers.forEach(header => {
    tableHtml += `<th>${header}</th>`;
  });
  tableHtml += '</tr>';
  
  // Track mismatches
  let mismatchFound = false;
  let mismatchCount = 0;
  let totalRows = rows.length;
  
  rows.forEach(row => {
    tableHtml += '<tr>';
    
    // Get the amount and creditor amount columns
    const amountIdx = headers.indexOf("AMOUNT");
    const creditorAmountIdx = headers.indexOf("CREDITOR AMOUNT");
    
    // Get values and normalize for comparison
    let amountStr = row[amountIdx] ? row[amountIdx].toString() : "";
    let creditorStr = row[creditorAmountIdx] ? row[creditorAmountIdx].toString() : "";
    
    // Compare numerical values with higher precision
    const amountNum = parseFloat(amountStr.replace(/[^0-9.]/g, ''));
    const creditorNum = parseFloat(creditorStr.replace(/[^0-9.]/g, ''));
    
    // Detect mismatch with very small tolerance for floating point precision issues
    const mismatch = Math.abs(amountNum - creditorNum) > 0.001;
    
    if (mismatch) {
      mismatchFound = true;
      mismatchCount++;
    }
    
    row.forEach((cell, index) => {
      // Add warning class to mismatched cells
      let cellClass = '';
      if (mismatch && (index === amountIdx || index === creditorAmountIdx)) {
        cellClass = ' class="mismatch-cell" data-original="' + cell + '"';
      }
      tableHtml += `<td${cellClass}>${cell}</td>`;
    });
    tableHtml += '</tr>';
  });
  tableHtml += '</table>';
  
  // Add warning if mismatches found
  if (mismatchFound) {
    tableHtml = `
      <div class="important-note">
        <span class="red-highlight"><i class="fas fa-exclamation-triangle"></i> <strong>WARNING:</strong> 
        Found ${mismatchCount} mismatches out of ${totalRows} rows between AMOUNT and CREDITOR AMOUNT columns (highlighted in red).</span>
      </div>
    ` + tableHtml;
  }
  
  return tableHtml;
}

// Improved Excel export with enhanced mismatch handling
tableExportBtn.querySelector('button').addEventListener('click', function() {
  // Convert TSV to array of arrays
  const rows = tsvOutput.value.split('\n').map(line => line.split('\t'));
  
  // Create workbook
  const wb = XLSX.utils.book_new();
  
  // Create main worksheet
  const ws = XLSX.utils.aoa_to_sheet(rows);
  
  // Find all mismatched cells from the table
  const mismatches = [];
  document.querySelectorAll('.mismatch-cell').forEach(cell => {
    const rowIndex = cell.parentElement.rowIndex;
    const colIndex = cell.cellIndex;
    const value = cell.textContent;
    mismatches.push({row: rowIndex, col: colIndex, value});
  });
  
  // Group mismatches by row
  const mismatchesByRow = {};
  mismatches.forEach(m => {
    if (!mismatchesByRow[m.row]) mismatchesByRow[m.row] = [];
    mismatchesByRow[m.row].push(m);
  });
  
  // Add styles to mismatched cells
  Object.keys(mismatchesByRow).forEach(rowKey => {
    const rowIdx = parseInt(rowKey);
    const rowMismatches = mismatchesByRow[rowKey];
    
    // Find amount and creditor amount cells
    const amountCell = rowMismatches.find(m => m.col === headers.indexOf("AMOUNT"));
    const creditorCell = rowMismatches.find(m => m.col === headers.indexOf("CREDITOR AMOUNT"));
    
    if (amountCell && creditorCell) {
      // Convert to Excel cell references (A1 notation)
      const amountCellRef = XLSX.utils.encode_cell({r: rowIdx, c: amountCell.col});
      const creditorCellRef = XLSX.utils.encode_cell({r: rowIdx, c: creditorCell.col});
      
      // Add cell formatting
      if (!ws[amountCellRef]) ws[amountCellRef] = {};
      if (!ws[creditorCellRef]) ws[creditorCellRef] = {};
      
      // Add styling information
      ws[amountCellRef].s = {
        fill: {fgColor: {rgb: "FFFF0000"}}, // Red background
        font: {color: {rgb: "FFFFFFFF"}, bold: true} // White, bold text
      };
      
      ws[creditorCellRef].s = {
        fill: {fgColor: {rgb: "FFFF0000"}},
        font: {color: {rgb: "FFFFFFFF"}, bold: true}
      };
    }
  });
  
  // Add summary sheet if mismatches found
  if (Object.keys(mismatchesByRow).length > 0) {
    const summaryData = [
      ["Mismatch Report"],
      ["Transaction No", "Amount", "Creditor Amount", "Difference"]
    ];
    
    Object.keys(mismatchesByRow).forEach(rowKey => {
      const rowIdx = parseInt(rowKey);
      const dataRow = rows[rowIdx];
      
      // Extract relevant data
      const txNo = dataRow[0];
      const amount = parseFloat(dataRow[4].replace(/[^0-9.]/g, ''));
      const creditor = parseFloat(dataRow[5].replace(/[^0-9.]/g, ''));
      const difference = Math.abs(amount - creditor).toFixed(2);
      
      summaryData.push([txNo, amount.toFixed(2), creditor.toFixed(2), difference]);
    });
    
    // Create summary worksheet
    const summaryWs = XLSX.utils.aoa_to_sheet(summaryData);
    XLSX.utils.book_append_sheet(wb, summaryWs, "Mismatches");
  }
  
  // Add main data sheet
  XLSX.utils.book_append_sheet(wb, ws, "Extracted Data");
  
  // Save Excel file
  XLSX.writeFile(wb, "table_data.xlsx");
});

// Add diagnostic helper that lets users try different OCR methods
function showOcrDiagnostics(imageUrl, ocrText) {
  if (!ocrText || !ocrText.match(/TRANSACTION/i)) {
    const diagnosticsDiv = document.createElement('div');
    diagnosticsDiv.style.margin = "20px 0";
    diagnosticsDiv.style.padding = "15px";
    diagnosticsDiv.style.backgroundColor = "#fff3f3"; 
    diagnosticsDiv.style.border = "1px solid #e74c3c";
    diagnosticsDiv.style.borderRadius = "5px";
    
    diagnosticsDiv.innerHTML = `
      <h3 style="color:#e74c3c;margin-top:0;">Screenshot Analysis</h3>
      <p>Image dimensions: <span id="img-dimensions">Calculating...</span></p>
      <p>OCR text extracted: ${ocrText ? ocrText.length : 0} characters</p>
      <p>Headers detected: ${ocrText ? (ocrText.match(/TRANSACTION/i) ? "Yes" : "No") : "No"}</p>
      <p>Table structure detected: ${ocrText ? (ocrText.match(/\d{6,}/) ? "Yes" : "No") : "No"}</p>
      <div style="margin-top:15px;">
        <button id="tryStrongerPreprocess" class="button" style="background:#e74c3c">Try Enhanced Screenshot Processing</button>
        <button id="tryDirectExtract" class="button secondary" style="margin-top:8px;">Try Direct Image Analysis</button>
      </div>
    `;
    
    statusArea.appendChild(diagnosticsDiv);
    
    // Calculate image dimensions
    const img = new Image();
    img.onload = function() {
      document.getElementById('img-dimensions').textContent = `${img.width}x${img.height} pixels`;
    };
    img.src = imageUrl;
    
    // Add button event handlers
    document.getElementById('tryStrongerPreprocess').addEventListener('click', async function() {
      statusArea.innerHTML = '<div class="loading">Applying enhanced screenshot processing...</div>';
      
      // Apply stronger preprocessing with scale 3.5 for much clearer text extraction
      const strongerProcessedUrl = await preprocessImage(await fetch(imageUrl).then(r => r.blob()), 3.5);
      previewImg.src = strongerProcessedUrl;
      
      // Process with the improved image
      processImage(strongerProcessedUrl);
    });
    
    // Direct image analysis option (experimental - for very clear screenshots)
    document.getElementById('tryDirectExtract').addEventListener('click', async function() {
      statusArea.innerHTML = '<div class="loading">Attempting direct screenshot analysis...</div>';
      
      try {
        // For direct analysis, we use a different OCR approach
        const result = await Tesseract.recognize(imageUrl, 'eng', {
          tessedit_pageseg_mode: 6, // Assume uniform text
          tessedit_ocr_engine_mode: 2, // LSTM + legacy for better number detection
          preserve_interword_spaces: 1,
          tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz/.: -',
        });
        
        ocrText.value = result.data.text;
        editArea.style.display = 'block';
        
        // Use our custom table parser
        const { rows, tsv } = parseTable(result.data.text);
        
        if (rows && rows.length > 0) {
          results.innerHTML = generateTable(HEADERS, rows);
          tsvOutput.value = tsv;
          tsvArea.style.display = 'block';
          tableExportBtn.style.display = 'block';
          statusArea.innerHTML = '<div class="success-message">✓ Table extracted using direct analysis!</div>';
        } else {
          results.innerHTML = '<div class="error-message">Direct analysis couldn\'t extract table data. Try using the "Auto-Fix Common Issues" button or a clearer screenshot.</div>';
          tableExportBtn.style.display = 'none';
        }
      } catch (error) {
        statusArea.innerHTML = '<div class="error-message">Direct analysis failed. Please try the enhanced processing.</div>';
      }
    });
  }
}

// Add this function before the event listeners section
async function processImage(imageUrl) {
  try {
    statusArea.innerHTML = '<div class="loading">Processing image with OCR...</div>';
    
    // Attempt OCR with our enhanced fallback system
    const ocrResult = await tryOcrWithFallbacks(imageUrl);
    
    // Store the OCR result in the text area and show the edit area
    ocrText.value = ocrResult;
    editArea.style.display = 'block';
    
    // Parse the extracted text into a table structure
    const { rows, tsv } = parseTable(ocrResult);
    
    if (rows && rows.length > 0) {
      // Generate and display HTML table
      results.innerHTML = generateTable(HEADERS, rows);
      
      // Store TSV data and display the export area
      tsvOutput.value = tsv;
      tsvArea.style.display = 'block';
      tableExportBtn.style.display = 'block';
      
      // Show success message
      statusArea.innerHTML = '<div class="success-message">✓ Table extracted successfully!</div>';
      
      // Scroll to results
      results.scrollIntoView({ behavior: 'smooth', block: 'start' });
    } else {
      // Handle unsuccessful extraction
      results.innerHTML = '<div class="error-message">Could not extract table data. Try using the "Auto-Fix Common Issues" button.</div>';
      tableExportBtn.style.display = 'none';
      
      // Show diagnostics to help debug OCR issues
      showOcrDiagnostics(imageUrl, ocrResult);
    }
  } catch (error) {
    // Handle errors
    statusArea.innerHTML = '<div class="error-message">Error: ' + error.message + '</div>';
    console.error("OCR processing error:", error);
    
    // Show diagnostics even in error case
    showOcrDiagnostics(imageUrl, "");
  }
}

// Replace the autoFixBtn event listener with this improved version
autoFixBtn.addEventListener('click', function() {
  statusArea.innerHTML = '<div class="loading">Applying automatic fixes...</div>';
  
  // Get current OCR text
  const text = ocrText.value;
  
  // Apply fixes (more comprehensive fixes than before)
  let fixedText = text
    // Fix number recognition errors
    .replace(/(\d),(\d)/g, "$1$2") // Remove commas inside numbers
    .replace(/(\d)\.(\d{2})0+/g, "$1.$2") // Fix trailing zeros
    .replace(/(\d)l(\d)/g, "$10$2") // Fix l/1 confusion
    .replace(/(\d)I(\d)/g, "$11$2") // Fix I/1 confusion
    .replace(/(\d)O(\d)/g, "$10$2") // Fix O/0 confusion
    .replace(/o\.(\d+)/g, "0.$1") // Fix o/0 in decimals
    
    // Fix column header recognition
    .replace(/TRANSACT[!|]ON/i, "TRANSACTION")
    .replace(/AMQUNT|AMO0UNT|AM0UNT/i, "AMOUNT")
    
    // Fix date format issues
    .replace(/(\d{1,2})[\.-](\d{1,2})[\.-](\d{4})/g, "$1/$2/$3")
    
    // Add spaces between numbers and words if missing
    .replace(/(\d)([A-Za-z])/g, "$1 $2")
    
    // Fix common OCR errors with decimals
    .replace(/(\d+)\.(\d+)\.(\d+)/g, "$1.$2$3") // Fix double decimals
    
    // Clean up extra spaces
    .replace(/\s{2,}/g, " ")
    .trim();
  
  // Update the OCR text area with the fixed text
  ocrText.value = fixedText;
  
  // Try parsing with the fixed text
  try {
    const { rows, tsv } = parseTable(fixedText);
    
    if (rows && rows.length > 0) {
      results.innerHTML = generateTable(HEADERS, rows);
      tsvOutput.value = tsv;
      tsvArea.style.display = 'block';
      tableExportBtn.style.display = 'block';
      statusArea.innerHTML = '<div class="success-message">✓ Table extracted after automatic fixes!</div>';
      
      // Scroll to results
      results.scrollIntoView({ behavior: 'smooth', block: 'start' });
    } else {
      // Try one more approach - adding line breaks between rows if they're merged
      fixedText = fixedText.replace(/(\d{6,})/g, "\n$1").trim();
      const result2 = parseTable(fixedText);
      
      if (result2.rows && result2.rows.length > 0) {
        results.innerHTML = generateTable(HEADERS, result2.rows);
        tsvOutput.value = result2.tsv;
        tsvArea.style.display = 'block';
        tableExportBtn.style.display = 'block';
        statusArea.innerHTML = '<div class="success-message">✓ Table extracted with enhanced fixes!</div>';
      } else {
        results.innerHTML = '<div class="error-message">Could not extract table data even after fixing. Try manual editing or a clearer screenshot.</div>';
        tableExportBtn.style.display = 'none';
        
        // Show direct extraction option
        showOcrDiagnostics(previewImg.src, fixedText);
      }
    }
  } catch (error) {
    console.error("Error during auto-fix:", error);
    statusArea.innerHTML = '<div class="error-message">Error during auto-fix: ' + error.message + '</div>';
  }
});

// --- Improved direct table extraction for screenshots ---
async function directTableExtraction() {
  ocrText.value = "";
  editArea.style.display = 'block';
  results.innerHTML = '<div class="loading">Performing advanced table extraction...</div>';

  const imageUrl = previewImg.src;
  if (!imageUrl) {
    results.innerHTML = '<div class="error-message">No image available for processing</div>';
    return;
  }

  const img = new Image();
  img.crossOrigin = "Anonymous";
  img.onload = async function() {
    // Draw image to canvas
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    ctx.drawImage(img, 0, 0);

    // --- Detect columns ---
    const columns = detectColumns(canvas, ctx);

    // --- Detect rows (horizontal projection) ---
    function detectRows(canvas, ctx) {
      const w = canvas.width, h = canvas.height;
      const projection = new Array(h).fill(0);
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const r = ctx.getImageData(x, y, 1, 1).data[0];
          if (r < 200) projection[y]++;
        }
      }
      let edges = [];
      let inRow = false;
      for (let y = 0; y < h; y++) {
        if (projection[y] > w * 0.03 && !inRow) { // was 0.01, now 0.03
          edges.push(y);
          inRow = true;
        } else if (projection[y] <= w * 0.01 && inRow) {
          inRow = false;
          edges.push(y);
        }
      }
      if (edges.length % 2 !== 0) edges.push(h);
      let rows = [];
      for (let i = 0; i < edges.length; i += 2) {
        // Ignore very small rows (header lines etc)
        if (edges[i+1] - edges[i] > 10) {
          rows.push({start: edges[i], end: edges[i+1]});
        }
      }
      return rows;
    }

    const rows = detectRows(canvas, ctx);

    // --- Validate detection ---
    if (columns.length !== HEADERS.length || rows.length < 2) {
      statusArea.innerHTML = '<div class="error-message">Direct extraction failed. Try Google Vision API for better results.</div>';
      addGoogleVisionFallback();
      return;
    }

    // --- Extract cells and run OCR on each cell ---
    results.innerHTML = '<div class="loading">Extracting table cells (this may take a few seconds)...</div>';
    let tableData = [];
    for (let rowIdx = 1; rowIdx < rows.length; rowIdx++) { // skip header row
      let row = [];
      for (let colIdx = 0; colIdx < columns.length; colIdx++) {
        const col = columns[colIdx];
        const rowBox = rows[rowIdx];
        // Crop cell
        const cellCanvas = document.createElement('canvas');
        cellCanvas.width = col.end - col.start;
        cellCanvas.height = rowBox.end - rowBox.start;
        const cellCtx = cellCanvas.getContext('2d');
        cellCtx.drawImage(
          canvas,
          col.start, rowBox.start, cellCanvas.width, cellCanvas.height,
          0, 0, cellCanvas.width, cellCanvas.height
        );
        // Run OCR on cell
        const cellDataUrl = cellCanvas.toDataURL('image/png');
        try {
          const cellResult = await Tesseract.recognize(cellDataUrl, 'eng', {
            tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz/.: -',
            tessedit_pageseg_mode: 7 // Treat as a single text line
          });
          row.push(cellResult.data.text.trim());
        } catch (e) {
          row.push('');
        }
      }
      tableData.push(row);
    }

    // --- Build table HTML and TSV ---
    let tsvRows = [HEADERS.join('\t')];
    let html = '<table class="results-table"><tr>' + HEADERS.map(h => `<th>${h}</th>`).join('') + '</tr>';
    tableData.forEach(row => {
      html += '<tr>' + row.map(cell => `<td>${cell}</td>`).join('') + '</tr>';
      tsvRows.push(row.join('\t'));
    });
    html += '</table>';

    results.innerHTML = html;
    tsvOutput.value = tsvRows.join('\n');
    tsvArea.style.display = 'block';
    tableExportBtn.style.display = 'block';
    statusArea.innerHTML = '<div class="success-message">✓ Table extracted directly from screenshot!</div>';
  };
  img.onerror = function() {
    results.innerHTML = '<div class="error-message">Could not load image for processing</div>';
  };
  img.src = imageUrl;
}

// Detect columns using vertical projection
function detectColumns(canvas, ctx) {
  const w = canvas.width, h = canvas.height;
  const projection = new Array(w).fill(0);
  for (let x = 0; x < w; x++) {
    for (let y = 0; y < h; y++) {
      const r = ctx.getImageData(x, y, 1, 1).data[0];
      if (r < 200) projection[x]++;
    }
  }
  // Find column edges by looking for large gaps in projection
  let edges = [];
  let inCol = false;
  for (let x = 0; x < w; x++) {
    if (projection[x] > h * 0.03 && !inCol) { // Increased threshold for screenshots
      edges.push(x);
      inCol = true;
    } else if (projection[x] <= h * 0.01 && inCol) {
      edges.push(x);
      inCol = false;
    }
  }
  if (edges.length % 2 !== 0) edges.push(w);

  // Merge columns that are too close together (less than 30px apart)
  let columns = [];
  for (let i = 0; i < edges.length; i += 2) {
    if (edges[i+1] - edges[i] > 30) { // Increased min width for screenshots
      // If previous column is very close, merge
      if (columns.length > 0 && edges[i] - columns[columns.length-1].end < 20) {
        columns[columns.length-1].end = edges[i+1];
      } else {
        columns.push({start: edges[i], end: edges[i+1]});
      }
    }
  }
  return columns;
}
  </script>
</body>
</html>
